# Loomi Pay 主应用接入指南

## 📋 概述

本文档详细说明了如何将您的主应用接入 Loomi Pay 独立支付微服务。Loomi Pay 采用异步事件驱动架构，通过 API 调用和 Redis Streams 消息队列实现与主应用的解耦通信。

## 🏗️ 架构概览

```mermaid
graph TD
    A[主应用] -->|1. 创建支付订单| B[Loomi Pay API]
    B -->|2. 返回订单信息| A
    B -->|3. 发布任务消息| C[Redis Streams]
    D[支付处理器] -->|4. 消费任务| C
    D -->|5. 调用拉卡拉| E[拉卡拉支付]
    E -->|6. 异步回调| F[Webhook处理]
    F -->|7. 发布结果消息| C
    A -->|8. 监听结果消息| C
    
    subgraph "Loomi Pay 服务"
        B
        C
        D
        F
        G[PostgreSQL]
    end
```

## 🚀 快速开始

### 1. 环境要求

- **网络访问**: 确保主应用可以访问 Loomi Pay 服务
- **Redis 连接**: 需要连接到同一个 Redis 实例
- **HTTPS**: 生产环境建议使用 HTTPS
- **API Key**: 从 Loomi Pay 管理员获取 API Key

### 2. 基础配置

在您的主应用中配置以下参数：

```env
# Loomi Pay 服务配置
LOOMI_PAY_BASE_URL=https://pay.your-domain.com
LOOMI_PAY_API_KEY=your-super-secret-api-key-here

# Redis 配置（与 Loomi Pay 共享）
REDIS_URL=redis://localhost:6379/0

# 应用标识
APP_ID=your_app_identifier
```

## 📡 API 接口详解

### 认证方式

所有 API 请求都需要在请求头中包含 API Key：

```http
Authorization: Bearer your-super-secret-api-key-here
Content-Type: application/json
```

### 1. 创建支付订单

**接口**: `POST /api/v1/payment-orders`

**用途**: 创建新的支付订单，支持支付和充值两种类型

**请求参数**:

```json
{
  "app_id": "your_app_identifier",
  "merchant_order_id": "ORDER_20241203_001",
  "amount": 10000,
  "order_type": "payment",
  "subject": "购买VIP会员",
  "currency": "CNY",
  "extra_data": {
    "user_id": "user_12345",
    "product_id": "vip_monthly",
    "return_url": "https://your-app.com/payment/return"
  }
}
```

**参数说明**:

| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| app_id | string | ✅ | 应用标识符，用于区分不同的应用 |
| merchant_order_id | string | ✅ | 商户订单号，在同一app_id下必须唯一 |
| amount | integer | ✅ | 金额，单位为分（例如：10000 = 100.00元） |
| order_type | string | ✅ | 订单类型：`payment`（支付）或 `recharge`（充值） |
| subject | string | ✅ | 订单标题/商品描述 |
| currency | string | ❌ | 货币类型，默认 "CNY" |
| extra_data | object | ❌ | 扩展数据，可存储业务相关信息 |

**响应示例**:

```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "app_id": "your_app_identifier",
  "merchant_order_id": "ORDER_20241203_001",
  "status": "pending",
  "order_type": "payment",
  "amount": 10000,
  "currency": "CNY",
  "payment_gateway": "lakala",
  "gateway_transaction_id": null,
  "subject": "购买VIP会员",
  "extra_data": {
    "user_id": "user_12345",
    "product_id": "vip_monthly",
    "return_url": "https://your-app.com/payment/return"
  },
  "created_at": "2024-12-03T10:30:00Z",
  "updated_at": "2024-12-03T10:30:00Z"
}
```

**状态码**:
- `202 Accepted`: 订单创建成功
- `409 Conflict`: 订单号已存在
- `400 Bad Request`: 参数错误
- `401 Unauthorized`: API Key 无效

### 2. 查询支付订单

**接口**: `GET /api/v1/payment-orders/{merchant_order_id}?app_id={app_id}`

**用途**: 查询指定订单的详细信息和当前状态

**请求示例**:
```http
GET /api/v1/payment-orders/ORDER_20241203_001?app_id=your_app_identifier
Authorization: Bearer your-super-secret-api-key-here
```

**响应示例**:
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "app_id": "your_app_identifier",
  "merchant_order_id": "ORDER_20241203_001",
  "status": "succeeded",
  "order_type": "payment",
  "amount": 10000,
  "currency": "CNY",
  "payment_gateway": "lakala",
  "gateway_transaction_id": "LKL_20241203_123456",
  "subject": "购买VIP会员",
  "extra_data": {
    "user_id": "user_12345",
    "product_id": "vip_monthly",
    "lakala_callback": {
      "payStatus": "S",
      "timestamp": "2024-12-03T10:35:00Z"
    }
  },
  "created_at": "2024-12-03T10:30:00Z",
  "updated_at": "2024-12-03T10:35:00Z"
}
```

**订单状态说明**:
- `pending`: 待处理
- `processing`: 处理中
- `succeeded`: 支付成功
- `failed`: 支付失败

### 3. 创建退款订单

**接口**: `POST /api/v1/refund-orders`

**用途**: 对已成功支付的订单发起退款

**请求参数**:
```json
{
  "app_id": "your_app_identifier",
  "payment_order_id": "550e8400-e29b-41d4-a716-446655440000",
  "amount": 5000,
  "reason": "用户申请退款"
}
```

**参数说明**:

| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| app_id | string | ✅ | 应用标识符 |
| payment_order_id | string | ✅ | 原支付订单的UUID |
| amount | integer | ✅ | 退款金额（分），不能超过原支付金额 |
| reason | string | ❌ | 退款原因 |

**响应示例**:
```json
{
  "id": "660f9500-f30c-42e5-b827-557766551111",
  "app_id": "your_app_identifier",
  "payment_order_id": "550e8400-e29b-41d4-a716-446655440000",
  "status": "pending",
  "amount": 5000,
  "currency": "CNY",
  "reason": "用户申请退款",
  "gateway_refund_id": null,
  "extra_data": {},
  "created_at": "2024-12-03T11:00:00Z",
  "updated_at": "2024-12-03T11:00:00Z"
}
```

### 4. 查询退款订单

**接口**: `GET /api/v1/refund-orders/{refund_order_id}?app_id={app_id}`

**用途**: 查询退款订单的详细信息和状态

## 📨 消息队列集成

### Redis Streams 配置

Loomi Pay 使用 Redis Streams 进行异步消息通信。主应用需要监听以下 Stream：

- **支付结果流**: `payment_results`
- **退款结果流**: `refund_results`

### 消息格式

#### 支付结果消息

```json
{
  "event_type": "payment_status_changed",
  "payment_order_id": "550e8400-e29b-41d4-a716-446655440000",
  "app_id": "your_app_identifier",
  "merchant_order_id": "ORDER_20241203_001",
  "old_status": "processing",
  "new_status": "succeeded",
  "gateway_transaction_id": "LKL_20241203_123456",
  "amount": 10000,
  "timestamp": "2024-12-03T10:35:00Z"
}
```

#### 退款结果消息

```json
{
  "event_type": "refund_status_changed",
  "refund_order_id": "660f9500-f30c-42e5-b827-557766551111",
  "payment_order_id": "550e8400-e29b-41d4-a716-446655440000",
  "app_id": "your_app_identifier",
  "old_status": "processing",
  "new_status": "succeeded",
  "gateway_refund_id": "LKL_REFUND_123456",
  "amount": 5000,
  "timestamp": "2024-12-03T11:05:00Z"
}
```

## 💻 代码示例

### Python 示例

```python
import requests
import redis
import json
from typing import Dict, Any, Optional

class LoomipayClient:
    def __init__(self, base_url: str, api_key: str, app_id: str, redis_url: str):
        self.base_url = base_url.rstrip('/')
        self.api_key = api_key
        self.app_id = app_id
        self.redis_client = redis.from_url(redis_url)
        self.headers = {
            'Authorization': f'Bearer {api_key}',
            'Content-Type': 'application/json'
        }
    
    def create_payment_order(self, 
                           merchant_order_id: str,
                           amount: int,
                           subject: str,
                           order_type: str = "payment",
                           extra_data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """创建支付订单"""
        url = f"{self.base_url}/api/v1/payment-orders"
        data = {
            "app_id": self.app_id,
            "merchant_order_id": merchant_order_id,
            "amount": amount,
            "order_type": order_type,
            "subject": subject,
            "extra_data": extra_data or {}
        }
        
        response = requests.post(url, json=data, headers=self.headers)
        response.raise_for_status()
        return response.json()
    
    def get_payment_order(self, merchant_order_id: str) -> Dict[str, Any]:
        """查询支付订单"""
        url = f"{self.base_url}/api/v1/payment-orders/{merchant_order_id}"
        params = {"app_id": self.app_id}
        
        response = requests.get(url, params=params, headers=self.headers)
        response.raise_for_status()
        return response.json()
    
    def create_refund_order(self,
                           payment_order_id: str,
                           amount: int,
                           reason: Optional[str] = None) -> Dict[str, Any]:
        """创建退款订单"""
        url = f"{self.base_url}/api/v1/refund-orders"
        data = {
            "app_id": self.app_id,
            "payment_order_id": payment_order_id,
            "amount": amount,
            "reason": reason
        }
        
        response = requests.post(url, json=data, headers=self.headers)
        response.raise_for_status()
        return response.json()
    
    def listen_payment_results(self, consumer_group: str = "main_app"):
        """监听支付结果消息"""
        stream_name = "payment_results"
        
        # 创建消费者组（如果不存在）
        try:
            self.redis_client.xgroup_create(stream_name, consumer_group, id='0', mkstream=True)
        except redis.exceptions.ResponseError:
            pass  # 组已存在
        
        while True:
            try:
                messages = self.redis_client.xreadgroup(
                    consumer_group,
                    f"{self.app_id}_consumer",
                    {stream_name: '>'},
                    count=1,
                    block=1000
                )
                
                for stream, msgs in messages:
                    for msg_id, fields in msgs:
                        # 解析消息
                        message_data = {k.decode(): v.decode() for k, v in fields.items()}
                        
                        # 只处理属于当前应用的消息
                        if message_data.get('app_id') == self.app_id:
                            self.handle_payment_result(message_data)
                            
                        # 确认消息已处理
                        self.redis_client.xack(stream_name, consumer_group, msg_id)
                        
            except Exception as e:
                print(f"处理消息时发生错误: {e}")
    
    def handle_payment_result(self, message_data: Dict[str, str]):
        """处理支付结果"""
        event_type = message_data.get('event_type')
        
        if event_type == 'payment_status_changed':
            merchant_order_id = message_data.get('merchant_order_id')
            new_status = message_data.get('new_status')
            
            print(f"订单 {merchant_order_id} 状态变更为: {new_status}")
            
            # 根据状态执行相应的业务逻辑
            if new_status == 'succeeded':
                self.handle_payment_success(message_data)
            elif new_status == 'failed':
                self.handle_payment_failure(message_data)
    
    def handle_payment_success(self, message_data: Dict[str, str]):
        """处理支付成功"""
        merchant_order_id = message_data.get('merchant_order_id')
        amount = int(message_data.get('amount', 0))
        
        # 在这里实现您的业务逻辑
        # 例如：发放积分、激活VIP、发送通知等
        print(f"支付成功处理: 订单{merchant_order_id}, 金额{amount}分")
    
    def handle_payment_failure(self, message_data: Dict[str, str]):
        """处理支付失败"""
        merchant_order_id = message_data.get('merchant_order_id')
        
        # 在这里实现您的业务逻辑
        # 例如：回滚订单状态、发送失败通知等
        print(f"支付失败处理: 订单{merchant_order_id}")

# 使用示例
if __name__ == "__main__":
    client = LoomipayClient(
        base_url="https://pay.your-domain.com",
        api_key="your-super-secret-api-key-here",
        app_id="your_app_identifier",
        redis_url="redis://localhost:6379/0"
    )
    
    # 创建支付订单
    order = client.create_payment_order(
        merchant_order_id="ORDER_20241203_001",
        amount=10000,  # 100.00元
        subject="购买VIP会员",
        extra_data={"user_id": "user_12345"}
    )
    print(f"创建订单成功: {order['id']}")
    
    # 查询订单状态
    order_info = client.get_payment_order("ORDER_20241203_001")
    print(f"订单状态: {order_info['status']}")
    
    # 启动消息监听（在单独的线程或进程中运行）
    # client.listen_payment_results()
```

### Node.js 示例

```javascript
const axios = require('axios');
const Redis = require('redis');

class LoomipayClient {
    constructor(baseUrl, apiKey, appId, redisUrl) {
        this.baseUrl = baseUrl.replace(/\/$/, '');
        this.apiKey = apiKey;
        this.appId = appId;
        this.redis = Redis.createClient({ url: redisUrl });
        this.headers = {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json'
        };
    }
    
    async createPaymentOrder(merchantOrderId, amount, subject, orderType = 'payment', extraData = {}) {
        const url = `${this.baseUrl}/api/v1/payment-orders`;
        const data = {
            app_id: this.appId,
            merchant_order_id: merchantOrderId,
            amount,
            order_type: orderType,
            subject,
            extra_data: extraData
        };
        
        try {
            const response = await axios.post(url, data, { headers: this.headers });
            return response.data;
        } catch (error) {
            throw new Error(`创建支付订单失败: ${error.response?.data?.detail || error.message}`);
        }
    }
    
    async getPaymentOrder(merchantOrderId) {
        const url = `${this.baseUrl}/api/v1/payment-orders/${merchantOrderId}`;
        const params = { app_id: this.appId };
        
        try {
            const response = await axios.get(url, { 
                headers: this.headers,
                params 
            });
            return response.data;
        } catch (error) {
            throw new Error(`查询支付订单失败: ${error.response?.data?.detail || error.message}`);
        }
    }
    
    async createRefundOrder(paymentOrderId, amount, reason = null) {
        const url = `${this.baseUrl}/api/v1/refund-orders`;
        const data = {
            app_id: this.appId,
            payment_order_id: paymentOrderId,
            amount,
            reason
        };
        
        try {
            const response = await axios.post(url, data, { headers: this.headers });
            return response.data;
        } catch (error) {
            throw new Error(`创建退款订单失败: ${error.response?.data?.detail || error.message}`);
        }
    }
    
    async listenPaymentResults(consumerGroup = 'main_app') {
        await this.redis.connect();
        
        const streamName = 'payment_results';
        const consumerName = `${this.appId}_consumer`;
        
        // 创建消费者组
        try {
            await this.redis.xGroupCreate(streamName, consumerGroup, '0', {
                MKSTREAM: true
            });
        } catch (error) {
            // 组已存在，忽略错误
        }
        
        while (true) {
            try {
                const messages = await this.redis.xReadGroup(
                    consumerGroup,
                    consumerName,
                    [{ key: streamName, id: '>' }],
                    { COUNT: 1, BLOCK: 1000 }
                );
                
                for (const message of messages) {
                    for (const msg of message.messages) {
                        const messageData = msg.message;
                        
                        // 只处理属于当前应用的消息
                        if (messageData.app_id === this.appId) {
                            await this.handlePaymentResult(messageData);
                        }
                        
                        // 确认消息已处理
                        await this.redis.xAck(streamName, consumerGroup, msg.id);
                    }
                }
            } catch (error) {
                console.error('处理消息时发生错误:', error);
            }
        }
    }
    
    async handlePaymentResult(messageData) {
        const eventType = messageData.event_type;
        
        if (eventType === 'payment_status_changed') {
            const merchantOrderId = messageData.merchant_order_id;
            const newStatus = messageData.new_status;
            
            console.log(`订单 ${merchantOrderId} 状态变更为: ${newStatus}`);
            
            if (newStatus === 'succeeded') {
                await this.handlePaymentSuccess(messageData);
            } else if (newStatus === 'failed') {
                await this.handlePaymentFailure(messageData);
            }
        }
    }
    
    async handlePaymentSuccess(messageData) {
        const merchantOrderId = messageData.merchant_order_id;
        const amount = parseInt(messageData.amount);
        
        // 在这里实现您的业务逻辑
        console.log(`支付成功处理: 订单${merchantOrderId}, 金额${amount}分`);
    }
    
    async handlePaymentFailure(messageData) {
        const merchantOrderId = messageData.merchant_order_id;
        
        // 在这里实现您的业务逻辑
        console.log(`支付失败处理: 订单${merchantOrderId}`);
    }
}

// 使用示例
async function main() {
    const client = new LoomipayClient(
        'https://pay.your-domain.com',
        'your-super-secret-api-key-here',
        'your_app_identifier',
        'redis://localhost:6379/0'
    );
    
    try {
        // 创建支付订单
        const order = await client.createPaymentOrder(
            'ORDER_20241203_001',
            10000, // 100.00元
            '购买VIP会员',
            'payment',
            { user_id: 'user_12345' }
        );
        console.log('创建订单成功:', order.id);
        
        // 查询订单状态
        const orderInfo = await client.getPaymentOrder('ORDER_20241203_001');
        console.log('订单状态:', orderInfo.status);
        
        // 启动消息监听
        // await client.listenPaymentResults();
        
    } catch (error) {
        console.error('操作失败:', error.message);
    }
}

// main();
```

## 🔄 完整业务流程

### 支付流程

1. **发起支付**
   ```python
   # 用户在主应用中点击支付
   order = client.create_payment_order(
       merchant_order_id="ORDER_123",
       amount=10000,
       subject="购买VIP"
   )
   ```

2. **获取支付链接**
   ```python
   # 从返回的订单信息中获取支付链接（通过后台任务生成）
   # 或者轮询订单状态直到获得支付链接
   order_info = client.get_payment_order("ORDER_123")
   if order_info['status'] == 'processing':
       # 引导用户到支付页面
       payment_url = order_info['extra_data']['payment_url']
   ```

3. **监听支付结果**
   ```python
   # 在后台服务中监听支付结果
   def handle_payment_success(message_data):
       merchant_order_id = message_data['merchant_order_id']
       # 更新用户VIP状态
       user_service.activate_vip(user_id)
       # 发送成功通知
       notification_service.send_payment_success(user_id)
   ```

### 退款流程

1. **发起退款**
   ```python
   # 管理员或用户申请退款
   refund = client.create_refund_order(
       payment_order_id=order['id'],
       amount=5000,  # 部分退款
       reason="用户申请"
   )
   ```

2. **监听退款结果**
   ```python
   def handle_refund_success(message_data):
       # 回滚用户权益
       # 发送退款成功通知
       pass
   ```

## ⚠️ 注意事项

### 1. 幂等性处理

- **merchant_order_id** 在同一 app_id 下必须唯一
- 相同参数的重复请求会返回已存在的订单
- 建议在订单号中包含时间戳或随机数

### 2. 错误处理

```python
try:
    order = client.create_payment_order(...)
except requests.exceptions.HTTPError as e:
    if e.response.status_code == 409:
        # 订单已存在，获取现有订单
        existing_order = client.get_payment_order(merchant_order_id)
    elif e.response.status_code == 401:
        # API Key 无效
        logger.error("API Key 认证失败")
    else:
        # 其他错误
        logger.error(f"创建订单失败: {e}")
```

### 3. 消息处理

- 确保消息处理的幂等性
- 合理设置消费者组和消费者名称
- 及时确认消息以避免重复处理
- 处理消息失败时的重试机制

### 4. 安全建议

- 妥善保管 API Key，不要提交到版本控制
- 使用 HTTPS 进行 API 通信
- 定期轮换 API Key
- 监控异常的 API 调用

### 5. 性能优化

- 使用连接池复用 HTTP 连接
- 合理设置超时时间
- 对频繁查询的订单状态进行缓存
- 批量处理消息队列中的消息

## 🔧 故障排查

### 常见问题

1. **API 调用失败**
   - 检查 API Key 是否正确
   - 确认网络连通性
   - 查看 Loomi Pay 服务日志

2. **消息无法接收**
   - 确认 Redis 连接配置
   - 检查消费者组是否创建成功
   - 验证 app_id 是否匹配

3. **订单状态异常**
   - 查看拉卡拉回调日志
   - 检查签名验证是否通过
   - 确认回调地址是否可访问

### 日志监控

建议在主应用中添加以下监控：

```python
import logging

# 配置日志
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# API 调用日志
logger.info(f"创建支付订单: {merchant_order_id}, 金额: {amount}")

# 消息处理日志
logger.info(f"收到支付结果: {message_data}")

# 错误日志
logger.error(f"支付处理失败: {error}", exc_info=True)
```

## 📞 技术支持

如有任何问题，请联系：

- **技术文档**: [GitHub Wiki](https://github.com/your-org/loomi-pay/wiki)
- **问题反馈**: [GitHub Issues](https://github.com/your-org/loomi-pay/issues)
- **邮箱支持**: tech-support@your-domain.com

---

**最后更新**: 2024年12月3日  
**文档版本**: v1.0.0
